<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java实现散列表（哈希表）</title>
      <link href="/2022/05/02/Java%E5%AE%9E%E7%8E%B0%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/"/>
      <url>/2022/05/02/Java%E5%AE%9E%E7%8E%B0%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="java实现散列表（哈希表）"><a href="#java实现散列表（哈希表）" class="headerlink" title="java实现散列表（哈希表）"></a>java实现散列表（哈希表）</h1><h2 id="散列表的建立"><a href="#散列表的建立" class="headerlink" title="散列表的建立"></a>散列表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>    class Node &#123;        public int id;        public String name;        public Node next;            public Node(int id, String name) &#123;            this.id = id;            this.name = name;        &#125;            @Override        public String toString() &#123;            return &quot;&#123;&quot; +                    &quot;id=&quot; + id +                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h5 id="创建数组节点，装链表"><a href="#创建数组节点，装链表" class="headerlink" title="创建数组节点，装链表"></a>创建数组节点，装链表</h5><pre><code>    class NodeLinkedList &#123;        Node head;&#125;</code></pre><h5 id="创建哈希数组"><a href="#创建哈希数组" class="headerlink" title="创建哈希数组"></a>创建哈希数组</h5><pre><code>    class HashTable &#123;        public NodeLinkedList[] nodeLinkedList;        public int size;//数组的大小            public HashTable(int size) &#123;            this.size = size;            nodeLinkedList = new NodeLinkedList[size];//数组初始化            //数组承载的链表初始化            for (int i = 0; i &lt; size; i++) &#123;                nodeLinkedList[i] = new NodeLinkedList();            &#125;        &#125;      &#125;</code></pre><h5 id="HashTable的散列函数，使用取余方法，得到hashcode值"><a href="#HashTable的散列函数，使用取余方法，得到hashcode值" class="headerlink" title="HashTable的散列函数，使用取余方法，得到hashcode值"></a>HashTable的散列函数，使用取余方法，得到hashcode值</h5><pre><code>         //散列函数          public int hash(int id) &#123;              return id % size;          &#125;</code></pre><h5 id="添加节点（首先在hashTable实现方法，由nodeLinkedList具体实现节点操作，删除修改查询遍历，操作相同）"><a href="#添加节点（首先在hashTable实现方法，由nodeLinkedList具体实现节点操作，删除修改查询遍历，操作相同）" class="headerlink" title="添加节点（首先在hashTable实现方法，由nodeLinkedList具体实现节点操作，删除修改查询遍历，操作相同）"></a>添加节点（首先在hashTable实现方法，由nodeLinkedList具体实现节点操作，删除修改查询遍历，操作相同）</h5><ul><li><p>尾插法</p><pre><code>   //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作   class HashTable &#123;       public void add(Node node) &#123;              //找到所在数组的位置              int index = hash(node.id);              nodeLinkedList[index].add(node);          &#125;   &#125;   class NodeLinkedList &#123;      //链表实现添加操作(尾插法)          public void add(Node node) &#123;              //链表没有元素              if (head == null) &#123;                  head = node;                  return;              &#125;              Node cur = head;              while (cur.next != null) &#123;                  cur = cur.next;              &#125;              cur.next = node;                &#125;   &#125;</code></pre></li><li><p>按照id的大小插入</p><pre><code>  //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作           class HashTable &#123;              public void addOrderById(Node node) &#123;                      //找到所在数组的位置                      int index = hash(node.id);                      nodeLinkedList[index].addOrderById(node);                  &#125;           &#125;           class NodeLinkedList &#123;               //插入元素按照大小                  public void addOrderById(Node node) &#123;                      if (head == null) &#123;                          head = node;                          return;                      &#125;                      if(head.id &gt; node.id)&#123;                          node.next = head;                          head = node;                          return;                      &#125;                      Node cur = head;                      boolean flag = false;                      while (cur.next != null) &#123;                          //中间位置有数值比node的id大的时候，提前跳出循环                          if (cur.next != null &amp;&amp; cur.next.id &gt; node.id) &#123;                              flag = true;                              break;                          &#125;                          cur = cur.next;                      &#125;                      if (flag) &#123;                          node.next = cur.next;                      &#125;                      cur.next = node;                                &#125;           &#125;</code></pre></li></ul><h5 id="删除节点（按照id删除节点）"><a href="#删除节点（按照id删除节点）" class="headerlink" title="删除节点（按照id删除节点）"></a>删除节点（按照id删除节点）</h5><pre><code>    //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作             class HashTable &#123;                //通过id值删除元素                    public boolean del(int id)&#123;                        if(size == 0)&#123;                            System.out.println(&quot;无元素，无法删除&quot;);                            return false;                        &#125;                        int index = hash(id);                        if(nodeLinkedList[index].del(id))&#123;                            return true;                        &#125;                        return false;                    &#125;             &#125;             class NodeLinkedList &#123;                 //通过id删除节点                    public boolean del(int id) &#123;                        if(head == null)&#123;                            return false;                        &#125;                        boolean flag = false;                        if(head.id == id &amp;&amp; head.next == null)&#123;                            head = null;                            return true;                        &#125;else if(head.id == id)&#123;                            head = head.next;                            return true;                        &#125;                        Node cur = head;                        while(cur.next != null)&#123;                            if(cur.next.id == id)&#123;                                flag = true;                                break;                            &#125;                            cur = cur.next;                        &#125;                        if(flag)&#123;                            if(cur.next.next != null)&#123;                                cur.next = cur.next.next;                            &#125;else&#123;                                cur.next = null;                            &#125;                        &#125;                        return flag;                    &#125;             &#125;</code></pre><h5 id="修改节点（按照id修改节点）"><a href="#修改节点（按照id修改节点）" class="headerlink" title="修改节点（按照id修改节点）"></a>修改节点（按照id修改节点）</h5><pre><code>    //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作             class HashTable &#123;                 //通过id修改内容                    public boolean changeById(int id,String name)&#123;                        if(size == 0)&#123;                            System.out.println(&quot;数组为空，无法更改元素&quot;);                            return false;                        &#125;                        int index = hash(id);                        if(nodeLinkedList[index].changeById(id,name))&#123;                            return true;                        &#125;                        return false;                    &#125;             &#125;             class NodeLinkedList &#123;                public boolean changeById(int id,String name) &#123;                        if(head == null)&#123;                            return false;                        &#125;                        if(head.id == id)&#123;                            head.name = name;                            return true;                        &#125;                        Node cur = head;                        while(cur != null)&#123;                            if(cur.id == id)&#123;                                break;                            &#125;                            cur = cur.next;                        &#125;                        if(cur != null)&#123;                            cur.name = name;                            return true;                        &#125;                        return false;                    &#125;             &#125;</code></pre><h5 id="查询内容（按照id查询节点）"><a href="#查询内容（按照id查询节点）" class="headerlink" title="查询内容（按照id查询节点）"></a>查询内容（按照id查询节点）</h5><pre><code>    //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作             class HashTable &#123;                 //通过id查找内容                    public Node findById(int id)&#123;                        if(size == 0)&#123;                            System.out.println(&quot;无元素，找不到&quot;);                            return null;                        &#125;                        int index = hash(id);                        if(nodeLinkedList[index].findById(id) != null)&#123;                            return nodeLinkedList[index].findById(id);                        &#125;                        return null;                    &#125;             &#125;             class NodeLinkedList &#123;                 public Node findById(int id) &#123;                        if(head == null)&#123;                            return null;                        &#125;                        Node cur = head;                        while(cur != null)&#123;                            if(cur.id == id)&#123;                                break;                            &#125;                            cur = cur.next;                        &#125;                        if(cur!= null)&#123;                            return cur;                        &#125;                        return null;                    &#125;             &#125;</code></pre><h5 id="遍历展示"><a href="#遍历展示" class="headerlink" title="遍历展示"></a>遍历展示</h5><pre><code>    //首先在hashTable实现方法，由nodeLinkedList具体实现节点操作             class HashTable &#123;                 //遍历展示散列表                    public void show() &#123;                        if (size == 0) &#123;                            System.out.println(&quot;哈希表为空！&quot;);                            return;                        &#125;                        for (int i = 0; i &lt; size; i++) &#123;                            nodeLinkedList[i].show(i);                        &#125;                    &#125;             &#125;             class NodeLinkedList &#123;                //遍历链表                    public void show(int no) &#123;                        if (head == null) &#123;                            System.out.println(&quot;第&quot; + (no + 1) + &quot;条链表为空&quot;);                            return;                        &#125;                        Node cur = head;                        System.out.print(&quot;第&quot; + (no + 1) + &quot;条链表信息为：&quot;);                        while(cur != null)&#123;                            System.out.print(cur +&quot;\t&quot;);                            cur = cur.next;                        &#125;                        System.out.println();                    &#125;             &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul><li><p>时间复杂度为O(n^2)</p><pre><code>   for (int i = 0; i &lt; list.length - 1; i++) &#123;              for (int j = 0; j &lt; list.length - 1 - i; j++) &#123;                  if(list[j] &gt; list[j+1])&#123;                      int temp = list[j];                      list[j] = list[j+1];                      list[j+1] = temp;                  &#125;              &#125;          &#125;</code></pre></li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><pre><code>    public static int[] choice(int[] list) &#123;            for (int i = 0; i &lt; list.length - 1; i++) &#123;                    int index = i;                for (int j = i + 1; j &lt; list.length; j++) &#123;                    if (list[index] &gt; list[j]) &#123;                        index = j;                    &#125;                &#125;                if (index != i) &#123;                    int tempt = list[i];                    list[i] = list[index];                    list[index] = tempt;                &#125;            &#125;            return list;        &#125;</code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><pre><code>    public static void insertArr(int[] list) &#123;            for (int i = 1; i &lt; list.length; i++) &#123;                int key = list[i];                int j = i - 1;                while (j &gt;= 0 &amp;&amp; list[j] &gt; key) &#123;                    list[j + 1] = list[j];                    j--;                &#125;                list[j + 1] = key;            &#125;            &#125;                   </code></pre><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><pre><code>      public static void shellList(int[] list) &#123;            //gap为一个步长            for (int gap = list.length / 2; gap &gt; 0; gap /= 2) &#123;                //假设步长开头0号位的节点是在正确的位置                for (int i = gap; i &lt; list.length; i++) &#123;                    int key = list[i];                    int j = i - gap;                    while (j &gt;= 0 &amp;&amp; list[j] &gt; key) &#123;                        //i点即j+gap变为list[j]的值，                        list[j+gap] = list[j];                        list[j] = key;                        j -= gap;                    &#125;                &#125;                System.out.println(Arrays.toString(list));            &#125;        &#125;</code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre><code>    public static void quickList(int[] list, int left, int right) &#123;            if (left &lt; right) &#123;                int midIndex = getMidIndex(list, left, right);                    if (left &lt; midIndex - 1) &#123;                    quickList(list, left, midIndex - 1);                &#125;                if (right &gt; midIndex + 1) &#123;                    quickList(list, midIndex + 1, right);                &#125;                &#125;        &#125;        private static int getMidIndex(int[] list, int left, int right) &#123;                //比较基数元素                int pivot = list[left];                while (left &lt; right) &#123;                    //将pivot比较右侧的元素，如果比pivot大，指针左移，如果比pivot小则填补前面取出的空值                    while (right &gt; left &amp;&amp; list[right] &gt;= pivot) &#123;                        right--;                    &#125;                    list[left] = list[right];                    //将pivot比较左侧的元素，如果比pivot小，指针右移，如果比pivot大，则填补右侧空出的位置                    while (left &lt; right &amp;&amp; list[left] &lt;= pivot) &#123;                        left++;                    &#125;                    list[right] = list[left];                &#125;                list[left] = pivot;                return left;            &#125;</code></pre><h1 id="归并排序（分治思想）"><a href="#归并排序（分治思想）" class="headerlink" title="归并排序（分治思想）"></a>归并排序（分治思想）</h1><pre><code>        public static void mergeList(int[] list, int left, int right) &#123;            if (left &lt; right) &#123;                int mid = left + (right - left) / 2;                mergeList(list, left, mid);                mergeList(list, mid + 1, right);                merge(list, left, mid, right);            &#125;        &#125;            private static void merge(int[] list, int left, int mid, int right) &#123;            System.out.println(&quot;我是merge&quot;);            int leftLength = mid - left + 1;            int rightLen = right - (mid + 1) + 1;            int[] leftTemp = new int[leftLength];            int[] rightTemp = new int[rightLen];            for (int i = 0; i &lt; leftTemp.length; i++) &#123;                leftTemp[i] = list[left + i];            &#125;            for (int i = 0; i &lt; rightTemp.length; i++) &#123;                rightTemp[i] = list[mid + 1 + i];            &#125;            int p = left;//临时数组的指针            int i = 0;            int j = 0;            while (i &lt; leftLength &amp;&amp; j &lt; rightLen) &#123;                if (leftTemp[i] &lt; rightTemp[j]) &#123;                    list[p] = leftTemp[i];                    i++;                &#125; else &#123;                    list[p] = rightTemp[j];                    j++;                &#125;                p++;            &#125;            //当上一个while循环结束，查看下是否左侧，或者右侧还有剩余的数据            while (i &lt; leftLength) &#123;                list[p] = leftTemp[i];                p++;                i++;            &#125;            while (j &lt; rightLen) &#123;                list[p] = rightTemp[j];                p++;                j++;            &#125;                &#125;</code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><pre><code>     public static void buketList(int[] list) &#123;            //新建几个桶，桶里面放数值,10表示从0-9位，后面的存放数据            int[][] buket = new int[10][list.length];            //新建一个数组，记录每个桶放入的数据个数            int[] buketCount = new int[10];            //求最大的数，求最大数的位数            int max = list[0];            for (int i = 1; i &lt; list.length; i++) &#123;                if (list[i] &gt; max) &#123;                    max = list[i];                &#125;            &#125;            //求最大数的位数            int n = (max + &quot;&quot;).length();            for (int i = 0; i &lt; n; i++) &#123;                //将list的数据放入桶中                for (int j = 0; j &lt; list.length; j++) &#123;                    int index = (int) (list[j] / Math.pow(10, i) % 10);                    buket[index][buketCount[index]] = list[j];                    buketCount[index]++;                &#125;                //将桶中的数据放入list中                int indexList = 0;                for (int j = 0; j &lt; buketCount.length; j++) &#123;                    if (buketCount[j] != 0) &#123;                        for (int k = 0; k &lt; buketCount[j]; k++) &#123;                            list[indexList++] = buket[j][k];                            &#125;                        buketCount[j] = 0;                    &#125;                    &#125;            &#125;                    //遍历每个桶将数据放入            for (int i = 0; i &lt; buket.length; i++) &#123;                &#125;            &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归问题</title>
      <link href="/2022/04/26/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/26/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java写递归问题"><a href="#Java写递归问题" class="headerlink" title="Java写递归问题"></a>Java写递归问题</h1><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><pre><code>     //汉诺塔        //借助b将a中的移动到c        public static void tower(int num, char a, char b, char c) &#123;            if (num == 1) &#123;                //直接将a塔的圆盘放到c                System.out.println(a + &quot;-&gt;&quot; + c);            &#125; else &#123;                //借助c将a上层的盘子移动到b                tower(num - 1, a, c, b);                //将a中最下层的盘子放到c中，记录下来                System.out.println(a + &quot;-&gt;&quot; + c);                //将b中剩余的盘子，借助a移动到c                tower(num-1,b,a,c);            &#125;        &#125;</code></pre><h2 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h2><pre><code>     /**         * 一堆桃子，猴子每天吃一半数量的桃子，然后再多偷吃一个，给定吃的天数，求解原来一共多少桃子         * 倒数第二天=（最后一天剩余桃子个数+1）*2         * @param day 吃到第几天         * @param n   最后一天剩余的桃子         * @return         */            //猴子吃桃        public static int houzi(int day, int n) &#123;            if (day == 1) &#123;                return n;            &#125; else &#123;                return houzi(day - 1, (n + 1) * 2);            &#125;        &#125;</code></pre><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><pre><code>    /**         * 迷宫的1为障碍，2表示通路，3表示走过的不通的路         *         * @param list     表示输入的数组         * @param startRow 开始位置的横坐标         * @param startCol 开始位置的纵坐标         * @return         */        public static boolean seek(int[][] list, int startRow, int startCol) &#123;            //若迷宫的出口为2，则找到路径，迷宫结束            if (list[5][6] == 2) &#123;                return true;            &#125; else &#123;                if (list[startRow][startCol] == 0) &#123;                    list[startRow][startCol] = 2;                    //判断该点能走通，继续下一步                    if (seek(list, startRow + 1, startCol)) &#123;//向下                        return true;                    &#125; else if (seek(list, startRow, startCol + 1)) &#123;//向右                        return true;                    &#125; else if (seek(list, startRow - 1, startCol)) &#123;//向上                        return true;                    &#125; else if (seek(list, startRow, startCol - 1)) &#123;//向左                        return true;                    &#125; else &#123;                        //走不通                        list[startRow][startCol] = 3;                        return false;                    &#125;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;            结果：        1 1 1 1 1 1 1 1          1 2 2 2 0 0 0 1          1 1 1 2 0 0 0 1          1 0 0 2 0 0 0 1          1 0 0 2 0 0 0 1          1 0 0 2 2 2 2 1          1 1 1 1 1 1 1 1  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用栈写简单逆波兰计算器思想及解释</title>
      <link href="/2022/04/25/Java%E4%BD%BF%E7%94%A8%E6%A0%88%E5%86%99%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/04/25/Java%E4%BD%BF%E7%94%A8%E6%A0%88%E5%86%99%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="逆波兰计算器实现"><a href="#逆波兰计算器实现" class="headerlink" title="逆波兰计算器实现"></a>逆波兰计算器实现</h1><h2 id="逆波兰计算器实现表达式计算"><a href="#逆波兰计算器实现表达式计算" class="headerlink" title="逆波兰计算器实现表达式计算"></a>逆波兰计算器实现表达式计算</h2><pre><code>     public static int cacul(List&lt;String&gt; list)&#123;            //定义一个数值栈            Stack&lt;String&gt; num = new Stack&lt;&gt;();            //遍历得到的list,如果是数据就push到栈中，如果是符号，取出栈顶的元素进行基本操作            for (String e : list)&#123;                //正则表达式                if(e.matches(&quot;\\d+&quot;))&#123;                    num.push(e);                &#125;else&#123;                    int num1 = Integer.parseInt(num.pop());                    int num2 = Integer.parseInt(num.pop());                    int res = 0;                    if (e.equals(&quot;+&quot;)) &#123;                        res = num1 + num2;                    &#125;else if (e.equals(&quot;-&quot;))&#123;                        res = num2 - num1;                    &#125;else if (e.equals(&quot;*&quot;))&#123;                        res = num1 * num2;                    &#125;else if (e.equals(&quot;/&quot;))&#123;                        res = num2 / num1;                    &#125;else&#123;                         return 0;                    &#125;                    num.push(res + &quot;&quot;);                &#125;                &#125;            //返回计算结果            return Integer.parseInt(num.pop());        &#125;        </code></pre><h1 id="中缀表达式变为后缀表达式（逆波兰）实现"><a href="#中缀表达式变为后缀表达式（逆波兰）实现" class="headerlink" title="中缀表达式变为后缀表达式（逆波兰）实现"></a>中缀表达式变为后缀表达式（逆波兰）实现</h1><h2 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h2><ul><li><p>数字压入数字栈（遍历pop出（即反向存储为正序））</p></li><li><p>符号，当遇到“（”时开始到“）”结束，中间所有符号暂时压入符号栈，遇到“）”后，将符号pop出栈到数字栈，直到删除至“（”；<br>其他符号看优先级，当前符号的优先级大于栈顶的符号优先级，则当前符号入符号栈，否则符号栈的符号出栈保存到数字栈，直到比当前符号的优先级高；<br>符号栈剩余的符号全部pop出至数字栈</p></li><li><p>举个栗子 例如A+B*(C+D)-E<br> 1.A为数字压入数字栈 数字栈：A<br> 2.“+”号压入符号栈 符号栈：+<br> 3.B为数字压入数字栈 数字栈：A，B<br> 4.“<em>”为符号，且优先级大于+ 压入符号栈 符号栈：+，</em><br> 5.“（”左侧括号压入符号栈 符号栈：+，<em>，（<br> 6.C为数字压入数字栈 数字栈：A，B，C<br> 7.“+” 入符号栈 符号栈：+，</em>，（，+<br> 8.D为数字压入数字栈 数字栈：A，B，C，D<br> 9.“）”为右括号，将“（”及中间符号出符号栈，压入数字栈，此时 数字栈：A，B，C，D ，+<br>                                                   符号栈：+，<em>，<br> 10.“+”为符号栈，“-”的优先级比符号栈的“</em>” 低，所以“<em>”出栈到数字栈，数字栈：A，B，C，D ，+，</em><br>                                                           符号栈：+，<br>          “-”的优先级比符号栈的+相等，所以“+”出栈到数字栈，数字栈：A，B，C，D ，+，*<br>                                                       符号栈：<br>           “-”号压入符号栈 符号栈：-<br> 11.E为数字，压入数字栈 数字栈：A，B，C，D ，+，<em>，E<br> 12.没有数据了，将符号栈的数据压入数字栈   A，B，C，D ，+，</em>，E，-</p></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><ul><li><p>中缀表达式转换成为中缀数组，便于遍历</p><pre><code>  public static List&lt;String&gt; midList(String str) &#123;          if (str == null) &#123;              return null;          &#125;          //去掉开头结尾的空格          str = str.trim();          List&lt;String&gt; list = new ArrayList&lt;&gt;();          char c = &#39; &#39;;          String s = &quot;&quot;;          for (int i = 0; i &lt; str.length(); i++) &#123;              c = str.charAt(i);              //为符号              if (c &lt; 48 || c &gt; 57) &#123;                  //1.当遇见符号时，说明数字结束，数字加入集合，并将数字串置空                  //最后一个符号后面的数字将在2.中添加                  list.add(s);                  s = &quot;&quot;;                  list.add(String.valueOf(c));                  continue;              &#125; else &#123;                  s += c;              &#125;          &#125;          //2.将最后一个数值放入          list.add(s);          return list;      &#125;</code></pre></li><li><p>中缀表达式转换成为逆波兰表达式</p><pre><code>  public static List&lt;String&gt; midChangeLast(List&lt;String&gt; list) &#123;          if (list.size() == 0) &#123;              return null;          &#125;          List&lt;String&gt; newList = new ArrayList&lt;&gt;();          String str = &quot;&quot;;          //数据栈  //        Stack&lt;String&gt; num = new Stack&lt;&gt;();          //符号栈          Stack&lt;String&gt; oper = new Stack&lt;&gt;();          for (int i = 0; i &lt; list.size(); i++) &#123;              str = list.get(i);              if (str.matches(&quot;\\d+&quot;)) &#123;                  newList.add(str);              &#125; else if (str.equals(&quot;(&quot;)) &#123;                  oper.push(str);              &#125; else if (str.equals(&quot;)&quot;)) &#123;                  while (!oper.peek().equals(&quot;(&quot;)) &#123;                      newList.add(oper.pop());                  &#125;                  oper.pop();              &#125; else &#123;//比较运算符的优先级，如果该运算符的优先级大于栈顶的运算符，该运算符入栈，否则栈顶运算符出栈                  while (oper.size() != 0 &amp;&amp; Operation.comp(str,oper.peek()) &lt;= 0)&#123;                      newList.add(oper.pop());                  &#125;                  oper.push(str);              &#125;          &#125;          while(oper.size() != 0)&#123;              newList.add(oper.pop());          &#125;            return newList;      &#125;</code></pre></li><li><p>符号优先级比较类Operation</p><pre><code>  class Operation &#123;      public static int comp(String str1, String str2) &#123;          return change(str1) - change(str2);      &#125;      public static int change(String str) &#123;          int res = 0;          switch (str) &#123;              case &quot;+&quot;:              case &quot;-&quot;:                  res = 1;                  break;              case &quot;*&quot;:              case &quot;/&quot;:                  res = 2;                  break;              default:                  break;          &#125;          return res;      &#125;  &#125;</code></pre></li></ul><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><pre><code>      String str = &quot;24+5*6-70/2+7*6+7+5-6*2-10&quot;;            System.out.println(cacul(midChangeLast(midList(str))));                              结果：51</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用数组和链表实现栈</title>
      <link href="/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java利用数组写栈结构"><a href="#java利用数组写栈结构" class="headerlink" title="java利用数组写栈结构"></a>java利用数组写栈结构</h1><h5 id="创建栈的类"><a href="#创建栈的类" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks &#123;        private int[] stack;        private int size;//栈的长度        private int top = -1;//栈没有值时，为-1            public Stacks(int size) &#123;            this.size = size;            stack = new int[this.size];        &#125;    &#125;</code></pre><h5 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素</p><pre><code>  public void push(int num) &#123;          if (!isFull()) &#123;              stack[++top] = num;          &#125; else &#123;              System.out.println(&quot;栈满了，不能添加&quot;);          &#125;      &#125;</code></pre></li><li><p>删除元素</p><pre><code>  public int pop() &#123;          if (isEmpty()) &#123;              System.out.println(&quot;栈为空，没有元素可以删除了&quot;);              return -1;          &#125;          return stack[top--];      &#125;</code></pre></li><li><p>展示栈元素，反向遍历，从尾端开始</p><pre><code>  public void show() &#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          for (int i = top; i &gt;= 0; i--) &#123;              System.out.println(stack[i]);          &#125;      &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty() &#123;          return top == -1;      &#125;</code></pre></li><li><p>是否满栈</p><pre><code>  public boolean isFull() &#123;          return top == size - 1;      &#125;</code></pre></li><li><p>栈长度</p><pre><code>   public int length() &#123;          return top == -1 ? 0 : top + 1;      &#125;</code></pre></li></ul><h1 id="java利用单链表写栈结构（push采用头插法）"><a href="#java利用单链表写栈结构（push采用头插法）" class="headerlink" title="java利用单链表写栈结构（push采用头插法）"></a>java利用单链表写栈结构（push采用头插法）</h1><h5 id="创建链表节点"><a href="#创建链表节点" class="headerlink" title="创建链表节点"></a>创建链表节点</h5><pre><code>    class Node&#123;        public int no;        public Node next;            public Node(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h5 id="创建栈的类-1"><a href="#创建栈的类-1" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks&#123;        Node top = new Node(-1);&#125;        </code></pre><h5 id="栈的操作-1"><a href="#栈的操作-1" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素,头插法</p><pre><code>  public void push(int num)&#123;          Node temp = new Node(num);          if(top.next != null)&#123;              temp.next = top.next;          &#125;          top.next = temp;      &#125;  </code></pre></li><li><p>删除元素</p><pre><code>  public int pop()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空，没有元素出栈&quot;);              return -1;          &#125;          Node cur = top.next;          top.next = cur.next;          return cur.no;      &#125;</code></pre></li><li><p>展示栈元素</p><pre><code>  public void show()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          Node cur = top.next;          while(cur != null)&#123;              System.out.println(cur);              cur = cur.next;          &#125;        &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(top.next == null)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表写约瑟夫环</title>
      <link href="/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="约瑟夫环结构实现"><a href="#约瑟夫环结构实现" class="headerlink" title="约瑟夫环结构实现"></a>约瑟夫环结构实现</h1><p><img src="https://bkimg.cdn.bcebos.com/pic/caef76094b36acaf2b72ccd47ed98d1001e99c03?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto"></p><h2 id="创建节点类"><a href="#创建节点类" class="headerlink" title="创建节点类"></a>创建节点类</h2><pre><code>    class LinkeNode &#123;        public int no;        public LinkeNode next;            public LinkeNode(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;LinkeNode&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h2 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h2><pre><code>    //单链表实现约瑟夫环    class LinkedList &#123;        //创建一个头节点        LinkeNode head = new LinkeNode(-1);&#125;</code></pre><h2 id="创建约瑟夫环形"><a href="#创建约瑟夫环形" class="headerlink" title="创建约瑟夫环形"></a>创建约瑟夫环形</h2><pre><code>        //创建约瑟夫环，输入约瑟夫环的大小值，自动创建约瑟夫环        public void add(int num) &#123;            if (num &lt; 1) &#123;                System.out.println(&quot;数值太小，无法创建环&quot;);                return;            &#125;            LinkeNode cur = head;            for (int i = 1; i &lt;= num; i++) &#123;                LinkeNode node = new LinkeNode(i);                cur.next = node;                node.next = head.next;                cur = cur.next;            &#125;            &#125;</code></pre><h2 id="遍历约瑟夫环"><a href="#遍历约瑟夫环" class="headerlink" title="遍历约瑟夫环"></a>遍历约瑟夫环</h2><pre><code>     //遍历约瑟夫环        public void show() &#123;            if (head.next == null) &#123;                System.out.println(&quot;空链表&quot;);                return;            &#125;            LinkeNode cur = head.next;            while (true) &#123;                System.out.println(cur);                if (cur.next == head.next) &#123;                    break;                &#125;                cur = cur.next;                &#125;        &#125;</code></pre><h1 id="丢手绢问题实现"><a href="#丢手绢问题实现" class="headerlink" title="丢手绢问题实现"></a>丢手绢问题实现</h1><pre><code>    //约瑟夫环丢手绢问题        public void OutLink(int startNo, int count, int num) &#123;            if (startNo &lt; 0 || num &lt; startNo || count &lt; 1) &#123;                System.out.println(&quot;输入值不合法&quot;);                return;            &#125;            //创建约瑟夫环            add(num);            //丢手绢问题,从第startNo个值开始出圈            //1.找到第startNo个节点            LinkeNode cur = head.next;            //辅助节点取到cur 的前一个节点，删除cur节点的时候使用            LinkeNode pre = head.next.next;            while (true) &#123;                if (pre.next == head.next) &#123;                    break;                &#125;                pre = pre.next;            &#125;            //找到初始数startNo节点            for (int i = 0; i &lt; startNo - 1; i++) &#123;                cur = cur.next;                pre = pre.next;            &#125;            //2.开始数数出圈            while (true) &#123;                if (cur == pre) &#123;                    break;                &#125;                for (int i = 0; i &lt; count - 1; i++) &#123;                    cur = cur.next;                    pre = pre.next;                &#125;                System.out.println(cur + &quot;出圈&quot;);                LinkeNode temp = pre;                pre.next = cur.next;                cur = pre.next;                pre = temp;                &#125;            System.out.println(&quot;最后出圈的值为&quot; + cur);            &#125;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><pre><code>         LinkedList linkedList = new LinkedList();         //从第一个开始，第2个出圈，队伍一共5个人         linkedList.OutLink(1, 2, 5);                  //结果：         LinkeNode&#123;no=2&#125;出圈         LinkeNode&#123;no=4&#125;出圈         LinkeNode&#123;no=1&#125;出圈         LinkeNode&#123;no=5&#125;出圈         最后出圈的值为LinkeNode&#123;no=3&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现双向链表</title>
      <link href="/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java写双向链表"><a href="#Java写双向链表" class="headerlink" title="Java写双向链表"></a>Java写双向链表</h1><h2 id="1-双向链表介绍"><a href="#1-双向链表介绍" class="headerlink" title="1.双向链表介绍"></a>1.双向链表介绍</h2><p>双向链表也叫双链表，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><h2 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h2><p><img src="https://img-blog.csdnimg.cn/20200506161836816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbnlfeWFuZzY=,size_16,color_FFFFFF,t_70"><br>data域–存放结点值的数据域<br>pre域–存放结点的直接前一个节点的地址（位置）的指针域（链域）<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）</p><h2 id="3-双链表的建立"><a href="#3-双链表的建立" class="headerlink" title="3.双链表的建立"></a>3.双链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>    class LinkNode&#123;        public int no;//双链表的内容值        public LinkNode pre;//前一个节点地址        public LinkNode next;//后一个节点地址，没有节点为null            public LinkNode(int no) &#123;            this.no = no;        &#125;    &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>   class DoubleLinkList&#123;   //初始化头节点       private LinkNode head = new LinkNode(0);          &#125;         </code></pre><h5 id="链表的建立操作"><a href="#链表的建立操作" class="headerlink" title="链表的建立操作"></a>链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code>   public void addHead(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          //将node的尾指针取到head的尾指针地址，将队伍拉到自己的尾巴后面          if (head.next != null) &#123;              node.next = head.next;              head.next.pre = node;          &#125;          //将node节点头放入到head节点后面            head.next = node;          node.pre = head;      &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          LinkNode cur = head;          while (cur.next != null) &#123;              cur = cur.next;          &#125;          cur.next = node;          node.pre = cur;      &#125;</code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>  public void addByIndex(int index, LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          if (index &lt; 0 || index &gt; length()) &#123;              System.out.println(&quot;输入值超出范围&quot;);              return;          &#125;          int count = 0;          LinkNode cur = head;          while (count &lt; index) &#123;              cur = cur.next;              count++;          &#125;            node.next = cur.next;          node.pre = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          cur.next = node;      &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>  public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;            LinkNode cur = head;          while (cur.next != null &amp;&amp; cur.next.no &lt; node.no) &#123;              cur = cur.next;          &#125;  //        LinkNode temp = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          node.next = cur.next;          node.pre = cur;          cur.next = node;          &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>  public boolean isHaveKey(int no) &#123;          if (isEmpty()) &#123;              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code> public boolean isEmpty() &#123;         if (head.next == null) &#123;             return true;         &#125;         return false;     &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              System.out.println(cur);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>   public int length() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return 0;          &#125;          LinkNode cur = head.next;          int count = 0;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>   public void del(int no) &#123;          if (isEmpty()) &#123;              System.out.println(&quot;链表为空，删除失败！&quot;);              return;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag) &#123;              cur.pre.next = cur.next;              if (cur.next != null) &#123;                  cur.next.pre = cur.pre;              &#125;              System.out.println(&quot;删除成功&quot;);              return;          &#125; else &#123;              System.out.println(&quot;没有数值为&quot; + no + &quot;的节点，删除失败&quot;);          &#125;        &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表</title>
      <link href="/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java写单链表"><a href="#java写单链表" class="headerlink" title="java写单链表"></a>java写单链表</h1><h2 id="1-单链表介绍"><a href="#1-单链表介绍" class="headerlink" title="1.单链表介绍"></a>1.单链表介绍</h2><p>链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><h2 id="2-链接方式存储的线性表简称为链表（Linked-List）"><a href="#2-链接方式存储的线性表简称为链表（Linked-List）" class="headerlink" title="2.链接方式存储的线性表简称为链表（Linked List）"></a>2.链接方式存储的线性表简称为链表（Linked List）</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/b2de9c82d158ccbfebe4998510d8bc3eb1354130?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto"><br>data域–存放结点值的数据域<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）<br>链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的，每个结点只有一个链域的链表称为单链表（Single Linked List）。</p><h2 id="3-单链表的建立"><a href="#3-单链表的建立" class="headerlink" title="3.单链表的建立"></a>3.单链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>      class LinkNode &#123;            public int no;//节点值            public LinkNode next;//后节点地址                    public LinkNode(int no) &#123;                this.no = no;            &#125;        &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>    class LinkList &#123;        //初始化头节点，以便于后面链表的各种操作           private LinkNode head = new LinkNode(0);        &#125;</code></pre><h5 id="单链表的建立操作"><a href="#单链表的建立操作" class="headerlink" title="单链表的建立操作"></a>单链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code> public void addHead(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点不能为空&quot;);                  return;              &#125;              LinkNode cur = head.next;              head.next = node;              node.next = cur;          &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点为空&quot;);                  return;              &#125;              //没有节点时              if (head.next == null) &#123;                  head.next = node;              &#125;else &#123;                  LinkNode cur = head.next;                  while (cur.next != null) &#123;                      cur = cur.next;                  &#125;                  cur.next = node;              &#125;          &#125;      </code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>   //特定位置插入节点(特定位置插入数值的话，可以将node换成data,在addByNo内部new LinkNode)              public void addByNo(int index, LinkNode node) &#123;                  if(node == null)&#123;                              System.out.println(&quot;插入节点为空&quot;);                              return;                          &#125;                  if (index &lt; 0 || index &gt; length()) &#123;                      System.out.println(&quot;插入节点位置值不合法！&quot;);                      return;                  &#125;                  if (index == 0) &#123;                      addHead(node);                      return;                  &#125;                  if (index == length()) &#123;                      addLast(node);                      return;                  &#125;                  LinkNode cur = head;                  int count = 0;                  while (cur != null) &#123;                      if (count == index) &#123;                          break;                      &#125;                      cur = cur.next;                      count++;                  &#125;                  node.next = cur.next;                  cur.next = node;                        &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>   public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;插入节点不能为空&quot;);              return;          &#125;          //第一次插入          if (head.next == null) &#123;              head.next = node;              return;          &#125; else &#123;              LinkNode cur = head;              boolean flag = false;                while (true) &#123;                  //node的值小，插在头节点                  if (cur.next == null) &#123;                      System.out.println(&quot;已到结尾&quot;);                      break;                  &#125;                    if (cur.next.no &gt; node.no) &#123;                      break;                  &#125; else if (cur.next.no == node.no) &#123;                      flag = true;                      break;                  &#125;                  cur = cur.next;              &#125;              if (!flag) &#123;                  node.next = cur.next;                  cur.next = node;              &#125; else &#123;                  System.out.println(&quot;存在相同节点，插入失败&quot;);              &#125;          &#125;      &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>   public boolean isHaveKey(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == key) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag == true) &#123;              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>节点值为key的前一个节点</p><pre><code>   //返回了一个节点，如查看内容，使用该方法.no的形式查看，注意如果查看的节点不存在，利用方法.no的形式时，会出现空指针异常    public LinkNode preNode(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return null;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur.next != null) &#123;              if (cur.next.no == key) &#123;                 return cur;              &#125;              cur = cur.next;          &#125;          return null;      &#125;</code></pre></li></ul><h5 id="单链表反转相关"><a href="#单链表反转相关" class="headerlink" title="单链表反转相关"></a>单链表反转相关</h5><pre><code>       public void reverse() &#123;            if (head.next == null || head.next.next == null) &#123;                return;            &#125;            //定义临时变量temp存放循环的cur.next节点，新建新的链表，最后将新链表赋值给原链表            LinkNode cur = head.next;            LinkNode temp = null;            LinkNode newLink = new LinkNode(0);            while (cur != null) &#123;                temp = cur.next;//保存cur.next节点，继续完成循环                cur.next = newLink.next;//cur节点的next值保存为新链表的next值，即在头插入当前的节点                newLink.next = cur;//将cur节点赋值给新链表                cur = temp;                            &#125;            head.next = newLink.next;        &#125;    </code></pre><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(head.next == null)&#123;              System.out.println(&quot;链表为空&quot;);              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>    public int length() &#123;          int count = 0;          LinkNode cur = head.next;          while (cur != null) &#123;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (cur != null) &#123;              System.out.println(cur.no);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>清空链表</p><pre><code>   public void clean()&#123;          head.next = null;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>  public void del(LinkNode node) &#123;          if(node == null || head.next == null)&#123;              System.out.println(&quot;不能删除空节点&quot;);              return;          &#125;            LinkNode cur = head;          boolean flag = false;          while (cur.next != null)&#123;              if(cur.next == node)&#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              cur.next = node.next;          &#125;else &#123;              System.out.println(&quot;元素不存在&quot;);          &#125;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
