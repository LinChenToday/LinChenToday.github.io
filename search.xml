<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java利用数组和链表实现栈</title>
      <link href="/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java利用数组写栈结构"><a href="#java利用数组写栈结构" class="headerlink" title="java利用数组写栈结构"></a>java利用数组写栈结构</h1><h5 id="创建栈的类"><a href="#创建栈的类" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks &#123;        private int[] stack;        private int size;//栈的长度        private int top = -1;//栈没有值时，为-1            public Stacks(int size) &#123;            this.size = size;            stack = new int[this.size];        &#125;    &#125;</code></pre><h5 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素</p><pre><code>  public void push(int num) &#123;          if (!isFull()) &#123;              stack[++top] = num;          &#125; else &#123;              System.out.println(&quot;栈满了，不能添加&quot;);          &#125;      &#125;</code></pre></li><li><p>删除元素</p><pre><code>  public int pop() &#123;          if (isEmpty()) &#123;              System.out.println(&quot;栈为空，没有元素可以删除了&quot;);              return -1;          &#125;          return stack[top--];      &#125;</code></pre></li><li><p>展示栈元素，反向遍历，从尾端开始</p><pre><code>  public void show() &#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          for (int i = top; i &gt;= 0; i--) &#123;              System.out.println(stack[i]);          &#125;      &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty() &#123;          return top == -1;      &#125;</code></pre></li><li><p>是否满栈</p><pre><code>  public boolean isFull() &#123;          return top == size - 1;      &#125;</code></pre></li><li><p>栈长度</p><pre><code>   public int length() &#123;          return top == -1 ? 0 : top + 1;      &#125;</code></pre></li></ul><h1 id="java利用单链表写栈结构（push采用头插法）"><a href="#java利用单链表写栈结构（push采用头插法）" class="headerlink" title="java利用单链表写栈结构（push采用头插法）"></a>java利用单链表写栈结构（push采用头插法）</h1><h5 id="创建链表节点"><a href="#创建链表节点" class="headerlink" title="创建链表节点"></a>创建链表节点</h5><pre><code>    class Node&#123;        public int no;        public Node next;            public Node(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h5 id="创建栈的类-1"><a href="#创建栈的类-1" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks&#123;        Node top = new Node(-1);&#125;        </code></pre><h5 id="栈的操作-1"><a href="#栈的操作-1" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素,头插法</p><pre><code>  public void push(int num)&#123;          Node temp = new Node(num);          if(top.next != null)&#123;              temp.next = top.next;          &#125;          top.next = temp;      &#125;  </code></pre></li><li><p>删除元素</p><pre><code>  public int pop()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空，没有元素出栈&quot;);              return -1;          &#125;          Node cur = top.next;          top.next = cur.next;          return cur.no;      &#125;</code></pre></li><li><p>展示栈元素</p><pre><code>  public void show()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          Node cur = top.next;          while(cur != null)&#123;              System.out.println(cur);              cur = cur.next;          &#125;        &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(top.next == null)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表写约瑟夫环</title>
      <link href="/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="约瑟夫环结构实现"><a href="#约瑟夫环结构实现" class="headerlink" title="约瑟夫环结构实现"></a>约瑟夫环结构实现</h1><p><img src="https://bkimg.cdn.bcebos.com/pic/caef76094b36acaf2b72ccd47ed98d1001e99c03?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto"></p><h2 id="创建节点类"><a href="#创建节点类" class="headerlink" title="创建节点类"></a>创建节点类</h2><pre><code>    class LinkeNode &#123;        public int no;        public LinkeNode next;            public LinkeNode(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;LinkeNode&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h2 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h2><pre><code>    //单链表实现约瑟夫环    class LinkedList &#123;        //创建一个头节点        LinkeNode head = new LinkeNode(-1);&#125;</code></pre><h2 id="创建约瑟夫环形"><a href="#创建约瑟夫环形" class="headerlink" title="创建约瑟夫环形"></a>创建约瑟夫环形</h2><pre><code>        //创建约瑟夫环，输入约瑟夫环的大小值，自动创建约瑟夫环        public void add(int num) &#123;            if (num &lt; 1) &#123;                System.out.println(&quot;数值太小，无法创建环&quot;);                return;            &#125;            LinkeNode cur = head;            for (int i = 1; i &lt;= num; i++) &#123;                LinkeNode node = new LinkeNode(i);                cur.next = node;                node.next = head.next;                cur = cur.next;            &#125;            &#125;</code></pre><h2 id="遍历约瑟夫环"><a href="#遍历约瑟夫环" class="headerlink" title="遍历约瑟夫环"></a>遍历约瑟夫环</h2><pre><code>     //遍历约瑟夫环        public void show() &#123;            if (head.next == null) &#123;                System.out.println(&quot;空链表&quot;);                return;            &#125;            LinkeNode cur = head.next;            while (true) &#123;                System.out.println(cur);                if (cur.next == head.next) &#123;                    break;                &#125;                cur = cur.next;                &#125;        &#125;</code></pre><h1 id="丢手绢问题实现"><a href="#丢手绢问题实现" class="headerlink" title="丢手绢问题实现"></a>丢手绢问题实现</h1><pre><code>    //约瑟夫环丢手绢问题        public void OutLink(int startNo, int count, int num) &#123;            if (startNo &lt; 0 || num &lt; startNo || count &lt; 1) &#123;                System.out.println(&quot;输入值不合法&quot;);                return;            &#125;            //创建约瑟夫环            add(num);            //丢手绢问题,从第startNo个值开始出圈            //1.找到第startNo个节点            LinkeNode cur = head.next;            //辅助节点取到cur 的前一个节点，删除cur节点的时候使用            LinkeNode pre = head.next.next;            while (true) &#123;                if (pre.next == head.next) &#123;                    break;                &#125;                pre = pre.next;            &#125;            //找到初始数startNo节点            for (int i = 0; i &lt; startNo - 1; i++) &#123;                cur = cur.next;                pre = pre.next;            &#125;            //2.开始数数出圈            while (true) &#123;                if (cur == pre) &#123;                    break;                &#125;                for (int i = 0; i &lt; count - 1; i++) &#123;                    cur = cur.next;                    pre = pre.next;                &#125;                System.out.println(cur + &quot;出圈&quot;);                LinkeNode temp = pre;                pre.next = cur.next;                cur = pre.next;                pre = temp;                &#125;            System.out.println(&quot;最后出圈的值为&quot; + cur);            &#125;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><pre><code>         LinkedList linkedList = new LinkedList();         //从第一个开始，第2个出圈，队伍一共5个人         linkedList.OutLink(1, 2, 5);                  //结果：         LinkeNode&#123;no=2&#125;出圈         LinkeNode&#123;no=4&#125;出圈         LinkeNode&#123;no=1&#125;出圈         LinkeNode&#123;no=5&#125;出圈         最后出圈的值为LinkeNode&#123;no=3&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现双向链表</title>
      <link href="/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java写双向链表"><a href="#Java写双向链表" class="headerlink" title="Java写双向链表"></a>Java写双向链表</h1><h2 id="1-双向链表介绍"><a href="#1-双向链表介绍" class="headerlink" title="1.双向链表介绍"></a>1.双向链表介绍</h2><p>双向链表也叫双链表，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><h2 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h2><p><img src="https://img-blog.csdnimg.cn/20200506161836816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbnlfeWFuZzY=,size_16,color_FFFFFF,t_70"><br>data域–存放结点值的数据域<br>pre域–存放结点的直接前一个节点的地址（位置）的指针域（链域）<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）</p><h2 id="3-双链表的建立"><a href="#3-双链表的建立" class="headerlink" title="3.双链表的建立"></a>3.双链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>    class LinkNode&#123;        public int no;//双链表的内容值        public LinkNode pre;//前一个节点地址        public LinkNode next;//后一个节点地址，没有节点为null            public LinkNode(int no) &#123;            this.no = no;        &#125;    &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>   class DoubleLinkList&#123;   //初始化头节点       private LinkNode head = new LinkNode(0);          &#125;         </code></pre><h5 id="链表的建立操作"><a href="#链表的建立操作" class="headerlink" title="链表的建立操作"></a>链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code>   public void addHead(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          //将node的尾指针取到head的尾指针地址，将队伍拉到自己的尾巴后面          if (head.next != null) &#123;              node.next = head.next;              head.next.pre = node;          &#125;          //将node节点头放入到head节点后面            head.next = node;          node.pre = head;      &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          LinkNode cur = head;          while (cur.next != null) &#123;              cur = cur.next;          &#125;          cur.next = node;          node.pre = cur;      &#125;</code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>  public void addByIndex(int index, LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          if (index &lt; 0 || index &gt; length()) &#123;              System.out.println(&quot;输入值超出范围&quot;);              return;          &#125;          int count = 0;          LinkNode cur = head;          while (count &lt; index) &#123;              cur = cur.next;              count++;          &#125;            node.next = cur.next;          node.pre = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          cur.next = node;      &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>  public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;            LinkNode cur = head;          while (cur.next != null &amp;&amp; cur.next.no &lt; node.no) &#123;              cur = cur.next;          &#125;  //        LinkNode temp = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          node.next = cur.next;          node.pre = cur;          cur.next = node;          &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>  public boolean isHaveKey(int no) &#123;          if (isEmpty()) &#123;              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code> public boolean isEmpty() &#123;         if (head.next == null) &#123;             return true;         &#125;         return false;     &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              System.out.println(cur);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>   public int length() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return 0;          &#125;          LinkNode cur = head.next;          int count = 0;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>   public void del(int no) &#123;          if (isEmpty()) &#123;              System.out.println(&quot;链表为空，删除失败！&quot;);              return;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag) &#123;              cur.pre.next = cur.next;              if (cur.next != null) &#123;                  cur.next.pre = cur.pre;              &#125;              System.out.println(&quot;删除成功&quot;);              return;          &#125; else &#123;              System.out.println(&quot;没有数值为&quot; + no + &quot;的节点，删除失败&quot;);          &#125;        &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表</title>
      <link href="/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java写单链表"><a href="#java写单链表" class="headerlink" title="java写单链表"></a>java写单链表</h1><h2 id="1-单链表介绍"><a href="#1-单链表介绍" class="headerlink" title="1.单链表介绍"></a>1.单链表介绍</h2><p>链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><h2 id="2-链接方式存储的线性表简称为链表（Linked-List）"><a href="#2-链接方式存储的线性表简称为链表（Linked-List）" class="headerlink" title="2.链接方式存储的线性表简称为链表（Linked List）"></a>2.链接方式存储的线性表简称为链表（Linked List）</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/b2de9c82d158ccbfebe4998510d8bc3eb1354130?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto"><br>data域–存放结点值的数据域<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）<br>链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的，每个结点只有一个链域的链表称为单链表（Single Linked List）。</p><h2 id="3-单链表的建立"><a href="#3-单链表的建立" class="headerlink" title="3.单链表的建立"></a>3.单链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>      class LinkNode &#123;            public int no;//节点值            public LinkNode next;//后节点地址                    public LinkNode(int no) &#123;                this.no = no;            &#125;        &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>    class LinkList &#123;        //初始化头节点，以便于后面链表的各种操作           private LinkNode head = new LinkNode(0);        &#125;</code></pre><h5 id="单链表的建立操作"><a href="#单链表的建立操作" class="headerlink" title="单链表的建立操作"></a>单链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code> public void addHead(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点不能为空&quot;);                  return;              &#125;              LinkNode cur = head.next;              head.next = node;              node.next = cur;          &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点为空&quot;);                  return;              &#125;              //没有节点时              if (head.next == null) &#123;                  head.next = node;              &#125;else &#123;                  LinkNode cur = head.next;                  while (cur.next != null) &#123;                      cur = cur.next;                  &#125;                  cur.next = node;              &#125;          &#125;      </code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>   //特定位置插入节点(特定位置插入数值的话，可以将node换成data,在addByNo内部new LinkNode)              public void addByNo(int index, LinkNode node) &#123;                  if(node == null)&#123;                              System.out.println(&quot;插入节点为空&quot;);                              return;                          &#125;                  if (index &lt; 0 || index &gt; length()) &#123;                      System.out.println(&quot;插入节点位置值不合法！&quot;);                      return;                  &#125;                  if (index == 0) &#123;                      addHead(node);                      return;                  &#125;                  if (index == length()) &#123;                      addLast(node);                      return;                  &#125;                  LinkNode cur = head;                  int count = 0;                  while (cur != null) &#123;                      if (count == index) &#123;                          break;                      &#125;                      cur = cur.next;                      count++;                  &#125;                  node.next = cur.next;                  cur.next = node;                        &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>   public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;插入节点不能为空&quot;);              return;          &#125;          //第一次插入          if (head.next == null) &#123;              head.next = node;              return;          &#125; else &#123;              LinkNode cur = head;              boolean flag = false;                while (true) &#123;                  //node的值小，插在头节点                  if (cur.next == null) &#123;                      System.out.println(&quot;已到结尾&quot;);                      break;                  &#125;                    if (cur.next.no &gt; node.no) &#123;                      break;                  &#125; else if (cur.next.no == node.no) &#123;                      flag = true;                      break;                  &#125;                  cur = cur.next;              &#125;              if (!flag) &#123;                  node.next = cur.next;                  cur.next = node;              &#125; else &#123;                  System.out.println(&quot;存在相同节点，插入失败&quot;);              &#125;          &#125;      &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>   public boolean isHaveKey(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == key) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag == true) &#123;              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>节点值为key的前一个节点</p><pre><code>   //返回了一个节点，如查看内容，使用该方法.no的形式查看，注意如果查看的节点不存在，利用方法.no的形式时，会出现空指针异常    public LinkNode preNode(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return null;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur.next != null) &#123;              if (cur.next.no == key) &#123;                 return cur;              &#125;              cur = cur.next;          &#125;          return null;      &#125;</code></pre></li></ul><h5 id="单链表反转相关"><a href="#单链表反转相关" class="headerlink" title="单链表反转相关"></a>单链表反转相关</h5><pre><code>       public void reverse() &#123;            if (head.next == null || head.next.next == null) &#123;                return;            &#125;            //定义临时变量temp存放循环的cur.next节点，新建新的链表，最后将新链表赋值给原链表            LinkNode cur = head.next;            LinkNode temp = null;            LinkNode newLink = new LinkNode(0);            while (cur != null) &#123;                temp = cur.next;//保存cur.next节点，继续完成循环                cur.next = newLink.next;//cur节点的next值保存为新链表的next值，即在头插入当前的节点                newLink.next = cur;//将cur节点赋值给新链表                cur = temp;                            &#125;            head.next = newLink.next;        &#125;    </code></pre><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(head.next == null)&#123;              System.out.println(&quot;链表为空&quot;);              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>    public int length() &#123;          int count = 0;          LinkNode cur = head.next;          while (cur != null) &#123;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (cur != null) &#123;              System.out.println(cur.no);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>清空链表</p><pre><code>   public void clean()&#123;          head.next = null;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>  public void del(LinkNode node) &#123;          if(node == null || head.next == null)&#123;              System.out.println(&quot;不能删除空节点&quot;);              return;          &#125;            LinkNode cur = head;          boolean flag = false;          while (cur.next != null)&#123;              if(cur.next == node)&#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              cur.next = node.next;          &#125;else &#123;              System.out.println(&quot;元素不存在&quot;);          &#125;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
