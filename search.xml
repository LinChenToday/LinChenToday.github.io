<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>递归问题</title>
      <link href="/2022/04/26/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/26/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java写递归问题"><a href="#Java写递归问题" class="headerlink" title="Java写递归问题"></a>Java写递归问题</h1><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><pre><code>     //汉诺塔        //借助b将a中的移动到c        public static void tower(int num, char a, char b, char c) &#123;            if (num == 1) &#123;                //直接将a塔的圆盘放到c                System.out.println(a + &quot;-&gt;&quot; + c);            &#125; else &#123;                //借助c将a上层的盘子移动到b                tower(num - 1, a, c, b);                //将a中最下层的盘子放到c中，记录下来                System.out.println(a + &quot;-&gt;&quot; + c);                //将b中剩余的盘子，借助a移动到c                tower(num-1,b,a,c);            &#125;        &#125;</code></pre><h2 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h2><pre><code>     /**         * 一堆桃子，猴子每天吃一半数量的桃子，然后再多偷吃一个，给定吃的天数，求解原来一共多少桃子         * 倒数第二天=（最后一天剩余桃子个数+1）*2         * @param day 吃到第几天         * @param n   最后一天剩余的桃子         * @return         */            //猴子吃桃        public static int houzi(int day, int n) &#123;            if (day == 1) &#123;                return n;            &#125; else &#123;                return houzi(day - 1, (n + 1) * 2);            &#125;        &#125;</code></pre><h2 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h2><pre><code>    /**         * 迷宫的1为障碍，2表示通路，3表示走过的不通的路         *         * @param list     表示输入的数组         * @param startRow 开始位置的横坐标         * @param startCol 开始位置的纵坐标         * @return         */        public static boolean seek(int[][] list, int startRow, int startCol) &#123;            //若迷宫的出口为2，则找到路径，迷宫结束            if (list[5][6] == 2) &#123;                return true;            &#125; else &#123;                if (list[startRow][startCol] == 0) &#123;                    list[startRow][startCol] = 2;                    //判断该点能走通，继续下一步                    if (seek(list, startRow + 1, startCol)) &#123;//向下                        return true;                    &#125; else if (seek(list, startRow, startCol + 1)) &#123;//向右                        return true;                    &#125; else if (seek(list, startRow - 1, startCol)) &#123;//向上                        return true;                    &#125; else if (seek(list, startRow, startCol - 1)) &#123;//向左                        return true;                    &#125; else &#123;                        //走不通                        list[startRow][startCol] = 3;                        return false;                    &#125;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;            结果：        1 1 1 1 1 1 1 1          1 2 2 2 0 0 0 1          1 1 1 2 0 0 0 1          1 0 0 2 0 0 0 1          1 0 0 2 0 0 0 1          1 0 0 2 2 2 2 1          1 1 1 1 1 1 1 1  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java使用栈写简单逆波兰计算器思想及解释</title>
      <link href="/2022/04/25/Java%E4%BD%BF%E7%94%A8%E6%A0%88%E5%86%99%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/04/25/Java%E4%BD%BF%E7%94%A8%E6%A0%88%E5%86%99%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E6%80%9D%E6%83%B3%E5%8F%8A%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="逆波兰计算器实现"><a href="#逆波兰计算器实现" class="headerlink" title="逆波兰计算器实现"></a>逆波兰计算器实现</h1><h2 id="逆波兰计算器实现表达式计算"><a href="#逆波兰计算器实现表达式计算" class="headerlink" title="逆波兰计算器实现表达式计算"></a>逆波兰计算器实现表达式计算</h2><pre><code>     public static int cacul(List&lt;String&gt; list)&#123;            //定义一个数值栈            Stack&lt;String&gt; num = new Stack&lt;&gt;();            //遍历得到的list,如果是数据就push到栈中，如果是符号，取出栈顶的元素进行基本操作            for (String e : list)&#123;                //正则表达式                if(e.matches(&quot;\\d+&quot;))&#123;                    num.push(e);                &#125;else&#123;                    int num1 = Integer.parseInt(num.pop());                    int num2 = Integer.parseInt(num.pop());                    int res = 0;                    if (e.equals(&quot;+&quot;)) &#123;                        res = num1 + num2;                    &#125;else if (e.equals(&quot;-&quot;))&#123;                        res = num2 - num1;                    &#125;else if (e.equals(&quot;*&quot;))&#123;                        res = num1 * num2;                    &#125;else if (e.equals(&quot;/&quot;))&#123;                        res = num2 / num1;                    &#125;else&#123;                         return 0;                    &#125;                    num.push(res + &quot;&quot;);                &#125;                &#125;            //返回计算结果            return Integer.parseInt(num.pop());        &#125;        </code></pre><h1 id="中缀表达式变为后缀表达式（逆波兰）实现"><a href="#中缀表达式变为后缀表达式（逆波兰）实现" class="headerlink" title="中缀表达式变为后缀表达式（逆波兰）实现"></a>中缀表达式变为后缀表达式（逆波兰）实现</h1><h2 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h2><ul><li><p>数字压入数字栈（遍历pop出（即反向存储为正序））</p></li><li><p>符号，当遇到“（”时开始到“）”结束，中间所有符号暂时压入符号栈，遇到“）”后，将符号pop出栈到数字栈，直到删除至“（”；<br>其他符号看优先级，当前符号的优先级大于栈顶的符号优先级，则当前符号入符号栈，否则符号栈的符号出栈保存到数字栈，直到比当前符号的优先级高；<br>符号栈剩余的符号全部pop出至数字栈</p></li><li><p>举个栗子 例如A+B*(C+D)-E<br> 1.A为数字压入数字栈 数字栈：A<br> 2.“+”号压入符号栈 符号栈：+<br> 3.B为数字压入数字栈 数字栈：A，B<br> 4.“<em>”为符号，且优先级大于+ 压入符号栈 符号栈：+，</em><br> 5.“（”左侧括号压入符号栈 符号栈：+，<em>，（<br> 6.C为数字压入数字栈 数字栈：A，B，C<br> 7.“+” 入符号栈 符号栈：+，</em>，（，+<br> 8.D为数字压入数字栈 数字栈：A，B，C，D<br> 9.“）”为右括号，将“（”及中间符号出符号栈，压入数字栈，此时 数字栈：A，B，C，D ，+<br>                                                   符号栈：+，<em>，<br> 10.“+”为符号栈，“-”的优先级比符号栈的“</em>” 低，所以“<em>”出栈到数字栈，数字栈：A，B，C，D ，+，</em><br>                                                           符号栈：+，<br>          “-”的优先级比符号栈的+相等，所以“+”出栈到数字栈，数字栈：A，B，C，D ，+，*<br>                                                       符号栈：<br>           “-”号压入符号栈 符号栈：-<br> 11.E为数字，压入数字栈 数字栈：A，B，C，D ，+，<em>，E<br> 12.没有数据了，将符号栈的数据压入数字栈   A，B，C，D ，+，</em>，E，-</p></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><ul><li><p>中缀表达式转换成为中缀数组，便于遍历</p><pre><code>  public static List&lt;String&gt; midList(String str) &#123;          if (str == null) &#123;              return null;          &#125;          //去掉开头结尾的空格          str = str.trim();          List&lt;String&gt; list = new ArrayList&lt;&gt;();          char c = &#39; &#39;;          String s = &quot;&quot;;          for (int i = 0; i &lt; str.length(); i++) &#123;              c = str.charAt(i);              //为符号              if (c &lt; 48 || c &gt; 57) &#123;                  //1.当遇见符号时，说明数字结束，数字加入集合，并将数字串置空                  //最后一个符号后面的数字将在2.中添加                  list.add(s);                  s = &quot;&quot;;                  list.add(String.valueOf(c));                  continue;              &#125; else &#123;                  s += c;              &#125;          &#125;          //2.将最后一个数值放入          list.add(s);          return list;      &#125;</code></pre></li><li><p>中缀表达式转换成为逆波兰表达式</p><pre><code>  public static List&lt;String&gt; midChangeLast(List&lt;String&gt; list) &#123;          if (list.size() == 0) &#123;              return null;          &#125;          List&lt;String&gt; newList = new ArrayList&lt;&gt;();          String str = &quot;&quot;;          //数据栈  //        Stack&lt;String&gt; num = new Stack&lt;&gt;();          //符号栈          Stack&lt;String&gt; oper = new Stack&lt;&gt;();          for (int i = 0; i &lt; list.size(); i++) &#123;              str = list.get(i);              if (str.matches(&quot;\\d+&quot;)) &#123;                  newList.add(str);              &#125; else if (str.equals(&quot;(&quot;)) &#123;                  oper.push(str);              &#125; else if (str.equals(&quot;)&quot;)) &#123;                  while (!oper.peek().equals(&quot;(&quot;)) &#123;                      newList.add(oper.pop());                  &#125;                  oper.pop();              &#125; else &#123;//比较运算符的优先级，如果该运算符的优先级大于栈顶的运算符，该运算符入栈，否则栈顶运算符出栈                  while (oper.size() != 0 &amp;&amp; Operation.comp(str,oper.peek()) &lt;= 0)&#123;                      newList.add(oper.pop());                  &#125;                  oper.push(str);              &#125;          &#125;          while(oper.size() != 0)&#123;              newList.add(oper.pop());          &#125;            return newList;      &#125;</code></pre></li><li><p>符号优先级比较类Operation</p><pre><code>  class Operation &#123;      public static int comp(String str1, String str2) &#123;          return change(str1) - change(str2);      &#125;      public static int change(String str) &#123;          int res = 0;          switch (str) &#123;              case &quot;+&quot;:              case &quot;-&quot;:                  res = 1;                  break;              case &quot;*&quot;:              case &quot;/&quot;:                  res = 2;                  break;              default:                  break;          &#125;          return res;      &#125;  &#125;</code></pre></li></ul><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><pre><code>      String str = &quot;24+5*6-70/2+7*6+7+5-6*2-10&quot;;            System.out.println(cacul(midChangeLast(midList(str))));                              结果：51</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用数组和链表实现栈</title>
      <link href="/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2022/04/23/Java%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="java利用数组写栈结构"><a href="#java利用数组写栈结构" class="headerlink" title="java利用数组写栈结构"></a>java利用数组写栈结构</h1><h5 id="创建栈的类"><a href="#创建栈的类" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks &#123;        private int[] stack;        private int size;//栈的长度        private int top = -1;//栈没有值时，为-1            public Stacks(int size) &#123;            this.size = size;            stack = new int[this.size];        &#125;    &#125;</code></pre><h5 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素</p><pre><code>  public void push(int num) &#123;          if (!isFull()) &#123;              stack[++top] = num;          &#125; else &#123;              System.out.println(&quot;栈满了，不能添加&quot;);          &#125;      &#125;</code></pre></li><li><p>删除元素</p><pre><code>  public int pop() &#123;          if (isEmpty()) &#123;              System.out.println(&quot;栈为空，没有元素可以删除了&quot;);              return -1;          &#125;          return stack[top--];      &#125;</code></pre></li><li><p>展示栈元素，反向遍历，从尾端开始</p><pre><code>  public void show() &#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          for (int i = top; i &gt;= 0; i--) &#123;              System.out.println(stack[i]);          &#125;      &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty() &#123;          return top == -1;      &#125;</code></pre></li><li><p>是否满栈</p><pre><code>  public boolean isFull() &#123;          return top == size - 1;      &#125;</code></pre></li><li><p>栈长度</p><pre><code>   public int length() &#123;          return top == -1 ? 0 : top + 1;      &#125;</code></pre></li></ul><h1 id="java利用单链表写栈结构（push采用头插法）"><a href="#java利用单链表写栈结构（push采用头插法）" class="headerlink" title="java利用单链表写栈结构（push采用头插法）"></a>java利用单链表写栈结构（push采用头插法）</h1><h5 id="创建链表节点"><a href="#创建链表节点" class="headerlink" title="创建链表节点"></a>创建链表节点</h5><pre><code>    class Node&#123;        public int no;        public Node next;            public Node(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h5 id="创建栈的类-1"><a href="#创建栈的类-1" class="headerlink" title="创建栈的类"></a>创建栈的类</h5><pre><code>    class Stacks&#123;        Node top = new Node(-1);&#125;        </code></pre><h5 id="栈的操作-1"><a href="#栈的操作-1" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li><p>添加元素,头插法</p><pre><code>  public void push(int num)&#123;          Node temp = new Node(num);          if(top.next != null)&#123;              temp.next = top.next;          &#125;          top.next = temp;      &#125;  </code></pre></li><li><p>删除元素</p><pre><code>  public int pop()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空，没有元素出栈&quot;);              return -1;          &#125;          Node cur = top.next;          top.next = cur.next;          return cur.no;      &#125;</code></pre></li><li><p>展示栈元素</p><pre><code>  public void show()&#123;          if(isEmpty())&#123;              System.out.println(&quot;栈为空&quot;);              return;          &#125;          Node cur = top.next;          while(cur != null)&#123;              System.out.println(cur);              cur = cur.next;          &#125;        &#125;</code></pre></li><li><p>是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(top.next == null)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表写约瑟夫环</title>
      <link href="/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/22/Java%E5%8D%95%E9%93%BE%E8%A1%A8%E5%86%99%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="约瑟夫环结构实现"><a href="#约瑟夫环结构实现" class="headerlink" title="约瑟夫环结构实现"></a>约瑟夫环结构实现</h1><p><img src="https://bkimg.cdn.bcebos.com/pic/caef76094b36acaf2b72ccd47ed98d1001e99c03?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto"></p><h2 id="创建节点类"><a href="#创建节点类" class="headerlink" title="创建节点类"></a>创建节点类</h2><pre><code>    class LinkeNode &#123;        public int no;        public LinkeNode next;            public LinkeNode(int no) &#123;            this.no = no;        &#125;            @Override        public String toString() &#123;            return &quot;LinkeNode&#123;&quot; +                    &quot;no=&quot; + no +                    &#39;&#125;&#39;;        &#125;    &#125;</code></pre><h2 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h2><pre><code>    //单链表实现约瑟夫环    class LinkedList &#123;        //创建一个头节点        LinkeNode head = new LinkeNode(-1);&#125;</code></pre><h2 id="创建约瑟夫环形"><a href="#创建约瑟夫环形" class="headerlink" title="创建约瑟夫环形"></a>创建约瑟夫环形</h2><pre><code>        //创建约瑟夫环，输入约瑟夫环的大小值，自动创建约瑟夫环        public void add(int num) &#123;            if (num &lt; 1) &#123;                System.out.println(&quot;数值太小，无法创建环&quot;);                return;            &#125;            LinkeNode cur = head;            for (int i = 1; i &lt;= num; i++) &#123;                LinkeNode node = new LinkeNode(i);                cur.next = node;                node.next = head.next;                cur = cur.next;            &#125;            &#125;</code></pre><h2 id="遍历约瑟夫环"><a href="#遍历约瑟夫环" class="headerlink" title="遍历约瑟夫环"></a>遍历约瑟夫环</h2><pre><code>     //遍历约瑟夫环        public void show() &#123;            if (head.next == null) &#123;                System.out.println(&quot;空链表&quot;);                return;            &#125;            LinkeNode cur = head.next;            while (true) &#123;                System.out.println(cur);                if (cur.next == head.next) &#123;                    break;                &#125;                cur = cur.next;                &#125;        &#125;</code></pre><h1 id="丢手绢问题实现"><a href="#丢手绢问题实现" class="headerlink" title="丢手绢问题实现"></a>丢手绢问题实现</h1><pre><code>    //约瑟夫环丢手绢问题        public void OutLink(int startNo, int count, int num) &#123;            if (startNo &lt; 0 || num &lt; startNo || count &lt; 1) &#123;                System.out.println(&quot;输入值不合法&quot;);                return;            &#125;            //创建约瑟夫环            add(num);            //丢手绢问题,从第startNo个值开始出圈            //1.找到第startNo个节点            LinkeNode cur = head.next;            //辅助节点取到cur 的前一个节点，删除cur节点的时候使用            LinkeNode pre = head.next.next;            while (true) &#123;                if (pre.next == head.next) &#123;                    break;                &#125;                pre = pre.next;            &#125;            //找到初始数startNo节点            for (int i = 0; i &lt; startNo - 1; i++) &#123;                cur = cur.next;                pre = pre.next;            &#125;            //2.开始数数出圈            while (true) &#123;                if (cur == pre) &#123;                    break;                &#125;                for (int i = 0; i &lt; count - 1; i++) &#123;                    cur = cur.next;                    pre = pre.next;                &#125;                System.out.println(cur + &quot;出圈&quot;);                LinkeNode temp = pre;                pre.next = cur.next;                cur = pre.next;                pre = temp;                &#125;            System.out.println(&quot;最后出圈的值为&quot; + cur);            &#125;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><pre><code>         LinkedList linkedList = new LinkedList();         //从第一个开始，第2个出圈，队伍一共5个人         linkedList.OutLink(1, 2, 5);                  //结果：         LinkeNode&#123;no=2&#125;出圈         LinkeNode&#123;no=4&#125;出圈         LinkeNode&#123;no=1&#125;出圈         LinkeNode&#123;no=5&#125;出圈         最后出圈的值为LinkeNode&#123;no=3&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现双向链表</title>
      <link href="/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/21/Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java写双向链表"><a href="#Java写双向链表" class="headerlink" title="Java写双向链表"></a>Java写双向链表</h1><h2 id="1-双向链表介绍"><a href="#1-双向链表介绍" class="headerlink" title="1.双向链表介绍"></a>1.双向链表介绍</h2><p>双向链表也叫双链表，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。</p><h2 id="2-双链表"><a href="#2-双链表" class="headerlink" title="2.双链表"></a>2.双链表</h2><p><img src="https://img-blog.csdnimg.cn/20200506161836816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvbnlfeWFuZzY=,size_16,color_FFFFFF,t_70"><br>data域–存放结点值的数据域<br>pre域–存放结点的直接前一个节点的地址（位置）的指针域（链域）<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）</p><h2 id="3-双链表的建立"><a href="#3-双链表的建立" class="headerlink" title="3.双链表的建立"></a>3.双链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>    class LinkNode&#123;        public int no;//双链表的内容值        public LinkNode pre;//前一个节点地址        public LinkNode next;//后一个节点地址，没有节点为null            public LinkNode(int no) &#123;            this.no = no;        &#125;    &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>   class DoubleLinkList&#123;   //初始化头节点       private LinkNode head = new LinkNode(0);          &#125;         </code></pre><h5 id="链表的建立操作"><a href="#链表的建立操作" class="headerlink" title="链表的建立操作"></a>链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code>   public void addHead(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          //将node的尾指针取到head的尾指针地址，将队伍拉到自己的尾巴后面          if (head.next != null) &#123;              node.next = head.next;              head.next.pre = node;          &#125;          //将node节点头放入到head节点后面            head.next = node;          node.pre = head;      &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          LinkNode cur = head;          while (cur.next != null) &#123;              cur = cur.next;          &#125;          cur.next = node;          node.pre = cur;      &#125;</code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>  public void addByIndex(int index, LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;          if (index &lt; 0 || index &gt; length()) &#123;              System.out.println(&quot;输入值超出范围&quot;);              return;          &#125;          int count = 0;          LinkNode cur = head;          while (count &lt; index) &#123;              cur = cur.next;              count++;          &#125;            node.next = cur.next;          node.pre = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          cur.next = node;      &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>  public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;不能插入空节点&quot;);              return;          &#125;            LinkNode cur = head;          while (cur.next != null &amp;&amp; cur.next.no &lt; node.no) &#123;              cur = cur.next;          &#125;  //        LinkNode temp = cur;          if (cur.next != null) &#123;              cur.next.pre = node;          &#125;          node.next = cur.next;          node.pre = cur;          cur.next = node;          &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>  public boolean isHaveKey(int no) &#123;          if (isEmpty()) &#123;              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              return true;          &#125;          return false;      &#125;</code></pre></li></ul><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code> public boolean isEmpty() &#123;         if (head.next == null) &#123;             return true;         &#125;         return false;     &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              System.out.println(cur);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>   public int length() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return 0;          &#125;          LinkNode cur = head.next;          int count = 0;          while (true) &#123;              if (cur == null) &#123;                  break;              &#125;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>   public void del(int no) &#123;          if (isEmpty()) &#123;              System.out.println(&quot;链表为空，删除失败！&quot;);              return;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == no) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag) &#123;              cur.pre.next = cur.next;              if (cur.next != null) &#123;                  cur.next.pre = cur.pre;              &#125;              System.out.println(&quot;删除成功&quot;);              return;          &#125; else &#123;              System.out.println(&quot;没有数值为&quot; + no + &quot;的节点，删除失败&quot;);          &#125;        &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java单链表</title>
      <link href="/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/04/20/Java%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java写单链表"><a href="#java写单链表" class="headerlink" title="java写单链表"></a>java写单链表</h1><h2 id="1-单链表介绍"><a href="#1-单链表介绍" class="headerlink" title="1.单链表介绍"></a>1.单链表介绍</h2><p>链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><h2 id="2-链接方式存储的线性表简称为链表（Linked-List）"><a href="#2-链接方式存储的线性表简称为链表（Linked-List）" class="headerlink" title="2.链接方式存储的线性表简称为链表（Linked List）"></a>2.链接方式存储的线性表简称为链表（Linked List）</h2><p><img src="https://bkimg.cdn.bcebos.com/pic/b2de9c82d158ccbfebe4998510d8bc3eb1354130?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto"><br>data域–存放结点值的数据域<br>next域–存放结点的直接后继的地址（位置）的指针域（链域）<br>链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的，每个结点只有一个链域的链表称为单链表（Single Linked List）。</p><h2 id="3-单链表的建立"><a href="#3-单链表的建立" class="headerlink" title="3.单链表的建立"></a>3.单链表的建立</h2><h5 id="创建节点类（在需要新的节点时，可以直接new新的节点）"><a href="#创建节点类（在需要新的节点时，可以直接new新的节点）" class="headerlink" title="创建节点类（在需要新的节点时，可以直接new新的节点）"></a>创建节点类（在需要新的节点时，可以直接new新的节点）</h5><pre><code>      class LinkNode &#123;            public int no;//节点值            public LinkNode next;//后节点地址                    public LinkNode(int no) &#123;                this.no = no;            &#125;        &#125;        </code></pre><h5 id="创建链表的类"><a href="#创建链表的类" class="headerlink" title="创建链表的类"></a>创建链表的类</h5><pre><code>    class LinkList &#123;        //初始化头节点，以便于后面链表的各种操作           private LinkNode head = new LinkNode(0);        &#125;</code></pre><h5 id="单链表的建立操作"><a href="#单链表的建立操作" class="headerlink" title="单链表的建立操作"></a>单链表的建立操作</h5><ul><li><p>头插法（较快）</p><pre><code> public void addHead(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点不能为空&quot;);                  return;              &#125;              LinkNode cur = head.next;              head.next = node;              node.next = cur;          &#125;</code></pre></li><li><p>尾插法（需要遍历）</p><pre><code>  public void addLast(LinkNode node) &#123;              if (node == null) &#123;                  System.out.println(&quot;插入节点为空&quot;);                  return;              &#125;              //没有节点时              if (head.next == null) &#123;                  head.next = node;              &#125;else &#123;                  LinkNode cur = head.next;                  while (cur.next != null) &#123;                      cur = cur.next;                  &#125;                  cur.next = node;              &#125;          &#125;      </code></pre></li><li><p>特定位置插入节点（需要遍历链表，比较耗时）</p><pre><code>   //特定位置插入节点(特定位置插入数值的话，可以将node换成data,在addByNo内部new LinkNode)              public void addByNo(int index, LinkNode node) &#123;                  if(node == null)&#123;                              System.out.println(&quot;插入节点为空&quot;);                              return;                          &#125;                  if (index &lt; 0 || index &gt; length()) &#123;                      System.out.println(&quot;插入节点位置值不合法！&quot;);                      return;                  &#125;                  if (index == 0) &#123;                      addHead(node);                      return;                  &#125;                  if (index == length()) &#123;                      addLast(node);                      return;                  &#125;                  LinkNode cur = head;                  int count = 0;                  while (cur != null) &#123;                      if (count == index) &#123;                          break;                      &#125;                      cur = cur.next;                      count++;                  &#125;                  node.next = cur.next;                  cur.next = node;                        &#125;</code></pre></li><li><p>按照no值从小到大的顺序插入链表</p><pre><code>   public void addOrderByNo(LinkNode node) &#123;          if (node == null) &#123;              System.out.println(&quot;插入节点不能为空&quot;);              return;          &#125;          //第一次插入          if (head.next == null) &#123;              head.next = node;              return;          &#125; else &#123;              LinkNode cur = head;              boolean flag = false;                while (true) &#123;                  //node的值小，插在头节点                  if (cur.next == null) &#123;                      System.out.println(&quot;已到结尾&quot;);                      break;                  &#125;                    if (cur.next.no &gt; node.no) &#123;                      break;                  &#125; else if (cur.next.no == node.no) &#123;                      flag = true;                      break;                  &#125;                  cur = cur.next;              &#125;              if (!flag) &#123;                  node.next = cur.next;                  cur.next = node;              &#125; else &#123;                  System.out.println(&quot;存在相同节点，插入失败&quot;);              &#125;          &#125;      &#125;</code></pre></li></ul><h5 id="单链表寻找节点操作"><a href="#单链表寻找节点操作" class="headerlink" title="单链表寻找节点操作"></a>单链表寻找节点操作</h5><ul><li><p>是否存在值为key的节点</p><pre><code>   public boolean isHaveKey(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return false;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur != null) &#123;              if (cur.no == key) &#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if (flag == true) &#123;              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>节点值为key的前一个节点</p><pre><code>   //返回了一个节点，如查看内容，使用该方法.no的形式查看，注意如果查看的节点不存在，利用方法.no的形式时，会出现空指针异常    public LinkNode preNode(int key) &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空，没有节点&quot;);              return null;          &#125;          LinkNode cur = head.next;          boolean flag = false;          while (cur.next != null) &#123;              if (cur.next.no == key) &#123;                 return cur;              &#125;              cur = cur.next;          &#125;          return null;      &#125;</code></pre></li></ul><h5 id="单链表反转相关"><a href="#单链表反转相关" class="headerlink" title="单链表反转相关"></a>单链表反转相关</h5><pre><code>       public void reverse() &#123;            if (head.next == null || head.next.next == null) &#123;                return;            &#125;            //定义临时变量temp存放循环的cur.next节点，新建新的链表，最后将新链表赋值给原链表            LinkNode cur = head.next;            LinkNode temp = null;            LinkNode newLink = new LinkNode(0);            while (cur != null) &#123;                temp = cur.next;//保存cur.next节点，继续完成循环                cur.next = newLink.next;//cur节点的next值保存为新链表的next值，即在头插入当前的节点                newLink.next = cur;//将cur节点赋值给新链表                cur = temp;                            &#125;            head.next = newLink.next;        &#125;    </code></pre><h5 id="单链表的其他操作"><a href="#单链表的其他操作" class="headerlink" title="单链表的其他操作"></a>单链表的其他操作</h5><ul><li><p>获取链表是否为空</p><pre><code>  public boolean isEmpty()&#123;          if(head.next == null)&#123;              System.out.println(&quot;链表为空&quot;);              return true;          &#125;          return false;      &#125;</code></pre></li><li><p>获取链表的长度</p><pre><code>    public int length() &#123;          int count = 0;          LinkNode cur = head.next;          while (cur != null) &#123;              count++;              cur = cur.next;          &#125;          return count;      &#125;</code></pre></li><li><p>遍历链表</p><pre><code>   public void show() &#123;          if (head.next == null) &#123;              System.out.println(&quot;链表为空&quot;);              return;          &#125;          LinkNode cur = head.next;          while (cur != null) &#123;              System.out.println(cur.no);              cur = cur.next;          &#125;      &#125;</code></pre></li><li><p>清空链表</p><pre><code>   public void clean()&#123;          head.next = null;      &#125;</code></pre></li><li><p>删除节点（遍历，效率低）</p><pre><code>  public void del(LinkNode node) &#123;          if(node == null || head.next == null)&#123;              System.out.println(&quot;不能删除空节点&quot;);              return;          &#125;            LinkNode cur = head;          boolean flag = false;          while (cur.next != null)&#123;              if(cur.next == node)&#123;                  flag = true;                  break;              &#125;              cur = cur.next;          &#125;          if(flag)&#123;              cur.next = node.next;          &#125;else &#123;              System.out.println(&quot;元素不存在&quot;);          &#125;      &#125;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
